**一、分布式架构的发展历史与背景**

**理解分布式**

分布式的概念比较复杂，简单的说分布式就是把一个节点来干的工作，现在由多个节点共同来完成。

**为什么要发展分布式**

1.稳定性和高可用这两个指标很难达到。如单点问题，一旦大型主机出现故障，那整个系统将处于不可用状态。

2.单机处理能力存在瓶颈。

3.升级单机处理能力的性价比越来越低。

**架构的发展史**

随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。

![横向发展图](image/image.png__thumbnail.png "横向发展图")

![纵向发展图](image/6oUvq7wnQZIPQM9t.png "纵向发展图")

**单体架构：**

![单体架构](image/image.png!thumbnail.png "单体架构")

**特点：**

* 所有的功能继承在一个项目工程中
* 所有的功能打成一个war包部署到服务器
* 应用与数据库分开部署
* 通过部署应用集群和数据库集群提高系统性能

**优点：**

项目架构简单，前期开发成本低，周期短，小型项目首选

**缺点：**

* 全部功能继承在一个工程中，对于大型项目不易开发，扩展，维护
* 系统性能扩展只能通过扩展集群节点，成本高，有瓶颈
* 技术栈受限

总结：耦合度大，项目臃肿，代码量飙升，运行的时间越长越不好维护

**垂直架构：**

![垂直架构](image/垂直.png "垂直架构")

**特点：**

* 以单体结构规模的项目为单位进行垂直划分项目，将一个大项目拆成一个一个单体结构的项目
* 项目与项目之间存在数据冗余，耦合度较大，可能三个项目中都有用户登录，用户信息等相同模块
* 项目之间的接口多位数据同步功能。数据库之间的数据通过网络接口进行数据同步

**优点：**

* 项目架构简单，前期开发成本低，周期短，小型项目首选
* 通过垂直拆分，原来的单体项目不至于无限扩大
* 不同的项目可采用不同的技术

**缺点：**

* 全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护
* 系统性能扩展只能通过扩展集群结点，成本高、有瓶颈

**分布式架构：**

![分布式架构](image/分布式.png "分布式架构")

**特点：**

* 基于SOA的架构思想将重复公用的功能抽取为组件，以服务的形式给各个系统提供服务
* 服务之间采用webservice，rpc等方式进行通信

**优点：**

* 将重复的功能抽取为服务，提高开发效率，提高系统的可重用性，可维护性
* 可以针对不同服务的特点制定集群以及优化方案

**缺点：**

* 系统与服务的界限模糊，不利于开发及维护
* 服务的接口协议不固定，种类繁多，不利于系统维护
* 抽取的服务粒度比较粗，系统与服务之间的耦合度高

![image-20210111170526271](image/image-20210111170526271.png)

**特点：**

* 将系统服务层完成独立出来，并将服务层抽取为一个一个微服务
* 微服务遵守单一原则
* 微服务之间采用restful，rpc等轻量协议传输

**优点：**

* 服务拆分粒度更细，有利于资源重复利用，提高开发效率
* 可以更加精准的制定每个服务的优化方案，提供系统可维护性
* 微服务架构采用去中心化思想，服务之间采用restful轻量协议通信
* 适用于互联网时代，产品迭代周期更短

**缺点：**

* 微服务过多，服务治理成本高，不利于系统维护
* 分布式系统开发的技术成本高（容错，分布式事务，分布式锁等），对团队挑战大

**二、改造升级分布式面临的问题：**

**分布式事务**

分布式事务指一个操作分成几个小操作在多个服务器上执行，要么都成功，要么都失败。

**不允许服务有状态（stateless service）**

无状态服务是指对单次请求的处理，不依赖其他请求。也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息。

**服务依赖关系复杂**

服务 A --> B--> C，服务C 的修改就可能会影响 B 和A。事实上当服务越来越多的时候，C的变动将会越来越困难。

**部署运维成本增加**

**源码管理成本增加**

 原本一套或几套源码现在拆分成几十个源码库，其中分支、tag都要进行相应管理。

**保证系统的伸缩性**

伸缩性指当前服务器硬件升级后或新增服务器处理能力能相应的提升。

**分布式会话**

此仅针对应用层服务，不能将Session 存储在一个服务器上。

**分布式job**

分布式环境下如何保证任务指触发一个，不会重复执行。

**三、技术选型**

![调用](image/diaoyong.png "调用")

**1.负载均衡：**这么多机器调用那一台

**2.服务发现：**怎样发现新的服务地址

**3.健康检测：**服务关宕机或恢复后怎么办

**4.容错：**调用的服务其中一台出了问题怎么办

**解决方案**

1.基于方向代理的中心化架构

最简单，最传统的方案，在服务消费者和生产者之间代理作为独立一层集中部署，由独立团队(一般是运维或架构)负责治理和运维。常用的集中式代理有硬件负载均衡器(如F5)，或者软件负载均衡器(如Nginx)，这种软硬结合两层代理也是业内常见做法，兼顾配置的灵活性(Nginx比F5易于配置)。

![介于反向代理的集中式分布式架构](image/反向代理1.png "介于反向代理的集中式分布式架构")

![轻量级分布式架构](image/反向代理2.png "轻量级分布式架构")

**http+nginx方案总结：**

优点：实现简单，快速，学习成本低

缺点：nginx中心负载，http传输，json序列化

2.嵌入应用内部的去中心化架构

这是很多互联网公司比较流行的一种做法，代理(包括服务发现和负载均衡逻辑)以客户库的形式嵌入在应用程序中。这种模式一般需要独立的服务注册中心组件配合，服务启动时自动注册到注册中心并定期报心跳，客户端代理则发现服务并做负载均衡。我们所熟悉的 dubbo+zookeeper和spring cloud Eureka +ribbon/feign或者nacos+ribbon/feign都是这种方式实现。

![去中心化](image/去中心化.png "去中心化")

**总结**，跟上一代架构比他的特点：

* 去中心化，客户端直接连服务端
* 动态注册和发现服务
* 高效稳定的网络传输
* 高效可容错的序列化

3.基于独立代理进程架构（service mesh）

这种做法是上面两种模式的一个折中，代理既不是独立集中部署，也不嵌入在客户应用程序中，而是作为独立进程部署在每一个主机上，一个主机上的多个消费者应用可以共用这个代理，实现服务发现和负载均衡，如下图所示。这个模式一般也需要独立的服务注册中心组件配合，作用同第二代架构。

![service mesh](image/servicMesh.png "service mesh")

**三种架构比较**

| 模式         | 优点                           | 缺点                         | 适用场景                 | 案例                       |
| ------------ | ------------------------------ | ---------------------------- | ------------------------ | :------------------------- |
| 集中式负载   | 简单，集中治理，与开发语言无关 | 维护成本高，多层io，单点     | 大部分都适用             | 携程，早期互联网公司       |
| 客户端嵌入式 | 无单点，性能好                 | 服务端复杂，语言技术栈要求高 | 中大规模应用，语言栈统一 | dubbo，spring cloud ribbon |
| 独立进程代理 | 无单点，性能好，与语言无关     | 运维部署复杂，开发联调复杂   | 中大规模应用，运维要求高 | smart stack，service mesh  |

